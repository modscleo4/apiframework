/**
 * Copyright 2022 Dhiego Cassiano Foga√ßa Barbosa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ReadStream, createReadStream, statSync } from "node:fs";
import { OutgoingHttpHeader, OutgoingHttpHeaders } from "node:http";
import { Readable, Transform } from "node:stream";
import { lookup } from "mime-types";

import { EStatusCode } from "./EStatusCode.js";
import Request from "./Request.js";
import HTTPError from "../errors/HTTPError.js";

/**
 * Problem Details for HTTP APIs.
 */
export type ProblemDetails = {
    /** A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation). */
    title: string;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail: string;
    /** The HTTP status code generated by the origin server for this occurrence of the problem. */
    status?: number;
    /** A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank". */
    type?: string;
    /** A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced. */
    instance?: string;
    /** Problem type definitions MAY extend the problem details object with additional members. */
    [key: string]: unknown;
};

type Bufferable = Buffer | string | (Buffer | string)[];
type Streamable = Readable | Iterable<Bufferable> | AsyncIterable<Bufferable>;

/**
 * Representation of a HTTP Response.
 *
 * @template T The type of the data to be sent.
 */
export default class Response<T = any> {
    #headers = new Map<string, OutgoingHttpHeader>();
    #status: number = EStatusCode.OK;
    #body: Buffer[] = [];
    #stream?: Readable;
    #pipeStreams: Transform[] = [];
    #earlyHints: Map<string, string[]> = new Map();

    static #transformers: Map<string, (data: unknown, options?: unknown) => Bufferable> = new Map();
    static #streamTransformers: Map<string, (data: unknown, options?: unknown) => Streamable> = new Map();

    static {
        Response.installTransformer('application/json', (data: unknown): Bufferable => {
            return JSON.stringify(data);
        });

        Response.installStreamTransformer('application/json', (data: unknown, options: unknown): Streamable => {
            return Readable.from(JSON.stringify(data, null, options as number));
        });

        Response.installTransformer('application/json-bigint', (data: unknown, options: unknown): Bufferable => {
            return JSON.stringify(data, (_, v) => typeof v === 'bigint' ? v.toString() + 'n' : v, options as number);
        });

        Response.installStreamTransformer('application/json-bigint', (data: unknown): Streamable => {
            return Readable.from(JSON.stringify(data, (_, v) => typeof v === 'bigint' ? v.toString() + 'n' : v));
        });
    }

    /**
     * Add a header to the response.
     *
     * @param key The header key.
     * @param value The header value.
     */
    withHeader<H extends keyof OutgoingHttpHeaders>(key: H, value: OutgoingHttpHeaders[H]): Response<T>;
    withHeader(key: string, value: OutgoingHttpHeader): Response<T> {
        // TODO: Add autocomplete for key.
        this.#headers.set(key as string, value!);

        return this;
    }

    /**
     * Add multiple headers to the response.
     *
     * @param headers The headers to be added.
     * @returns The response object.
     */
    withHeaders(headers: OutgoingHttpHeaders): Response<T> {
        for (const key in headers) {
            const value = headers[key]!;
            this.#headers.set(key, value);
        }

        return this;
    }

    /**
     * Add a cookie to the response. The Set-Cookie header will be set and automatically appended.
     *
     * @param key The cookie key.
     * @param value The cookie value.
     * @param options The cookie options.
     * @returns The response object.
     */
    withCookie(key: string, value: string, options?: {
        domain?: string;
        path?: string;
        expires?: Date;
        maxAge?: number;
        secure?: boolean;
        httpOnly?: boolean;
        sameSite?: 'strict' | 'lax' | 'none';
    }): Response<T> {
        let cookie = `${key}=${value};`;

        if (options?.domain) {
            cookie += ` Domain=${options.domain};`;
        }

        if (options?.path) {
            cookie += ` Path=${options.path};`;
        }

        if (options?.expires) {
            cookie += ` Expires=${options.expires.toUTCString()};`;
        }

        if (options?.maxAge) {
            cookie += ` Max-Age=${options.maxAge};`;
        }

        if (options?.secure) {
            cookie += ' Secure;';
        }

        if (options?.httpOnly) {
            cookie += ' HttpOnly;';
        }

        if (options?.sameSite) {
            cookie += ` SameSite=${options.sameSite};`;
        }

        if (this.#headers.has('Set-Cookie')) {
            const setCookie = this.#headers.get('Set-Cookie')!;
            if (Array.isArray(setCookie)) {
                setCookie.push(cookie);
            } else {
                this.#headers.set('Set-Cookie', [setCookie as string, cookie]);
            }
        } else {
            this.#headers.set('Set-Cookie', [cookie]);
        }

        return this;
    }

    /**
     * Add an early hint to the response. It uses the `res.writeEarlyHints` method.
     *
     * @param key The header key.
     * @param value The header value.
     * @returns The response object.
     */
    withEarlyHint(key: string, value: string): Response<T> {
        if (!this.#earlyHints.has(key)) {
            this.#earlyHints.set(key, []);
        }

        this.#earlyHints.get(key)!.push(value);

        return this;
    }

    /**
     * Send pure data. Automatically converts strings to Buffers using UTF-8 encoding.
     *
     * @param data The data to be sent. If an array is passed, each item will be sent as a separate chunk.
     * @returns The response object.
     */
    send(data: Bufferable): Response<T> {
        if (Array.isArray(data)) {
            for (const chunk of data) {
                this.#body.push(typeof chunk === 'string' ? Buffer.from(chunk, 'utf8') : chunk);
            }
        } else {
            this.#body.push(typeof data === 'string' ? Buffer.from(data, 'utf8') : data);
        }

        return this;
    }

    /**
     * Send a stream. Streams have priority over other data.
     *
     * @param stream The stream to be sent.
     * @returns The response object.
     */
    stream(stream: Streamable): Response<T> {
        this.#stream = stream instanceof Readable ? stream : Readable.from(stream);

        return this;
    }

    /**
     * Send JSON data. The Content-Type header will be set to application/json and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    json(data: T, stream: boolean = false, spaces?: number): Response<T> {
        this.withHeader('Content-Type', 'application/json');
        if (stream) {
            this.stream(Response.#streamTransformers.get('application/json')!(data, spaces));
        } else {
            this.send(Response.#transformers.get('application/json')!(data, spaces));
        }

        return this;
    }

    /**
     * Send JSON data with BigInt support. The Content-Type header will be set to application/json-bigint and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    jsonBigint(data: T, stream: boolean = false, spaces?: number): Response<T> {
        this.withHeader('Content-Type', 'application/json-bigint');
        if (stream) {
            this.stream(Response.#streamTransformers.get('application/json-bigint')!(data, spaces));
        } else {
            this.send(Response.#transformers.get('application/json-bigint')!(data, spaces));
        }

        return this;
    }

    /**
     * Send a Problem Details response.
     * @param title A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation).
     * @param detail A human-readable explanation specific to this occurrence of the problem.
     * @param status The HTTP status code generated by the origin server for this occurrence of the problem.
     * @param type A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
     * @param instance A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @param extensions Problem type definitions MAY extend the problem details object with additional members.
     * @returns The response object.
     */
    problem(title: string, detail: string, status?: number, type?: string | null, instance?: string, extensions?: Record<string, unknown>): Response<ProblemDetails> {
        (<Response<ProblemDetails>> this).json({
            title,
            detail,
            status,
            type: type ?? 'about:blank',
            instance,
            ...extensions
        })
            .withHeader('Content-Type', 'application/problem+json');

        if (status) {
            this.withStatus(status);
        }

        return (<Response<ProblemDetails>> this);
    }

    /**
     * Send data based on the Accept header of the request. The Content-Type header will be set accordingly.
     *
     * @param data The data to be sent.
     * @param req The request object.
     * @param order The order of priority for the Accept header. If not set, the order will be based on the request's Accept header.
     * @returns The response object.
     */
    auto(data: T, req: Request, order?: string[]): Response<T> {
        const priority = order ?? req.acceptPriority;

        for (const type of priority) {
            if (type.endsWith('/*')) {
                const baseType = type.slice(0, -2);
                const transformers = Array.from(Response.#transformers.keys()).filter(t => t.startsWith(baseType));

                if (transformers.length > 0) {
                    this.withHeader('Content-Type', transformers[0])
                        .send(Response.#transformers.get(transformers[0])!(data));

                    return this;
                }
            } else if (Response.#transformers.has(type)) {
                this.withHeader('Content-Type', type)
                    .send(Response.#transformers.get(type)!(data));

                return this;
            }
        }

        if (priority.includes('*/*')) {
            const transformer = 'application/json';

            this.withHeader('Content-Type', transformer)
                .send(Response.#transformers.get(transformer)!(data));

            return this;
        }

        throw new HTTPError('This server cannot process the requested Content-Type.', EStatusCode.NOT_ACCEPTABLE);
    }

    /**
     * Send a HTML response. The Content-Type header will be set to text/html.
     *
     * @param data The HTML data to be sent.
     * @returns The response object.
     */
    html(data: string): Response<T> {
        return this.withHeader('Content-Type', 'text/html')
            .send(data);
    }

    /**
     * Send a File. The Content-Type header will be set based on the filename. The file will be streamed.
     *
     * @param filename The path to the file to be sent.
     * @param req The request object. If the request has a Range header, the file will be sent partially.
     * @returns The response object.
     */
    file(filename: string, req?: Request): Response<T> {
        function parseRange(range: string): [number, number] {
            if (/^\d+-\d+$/.test(range)) {
                const [start, end] = range.split('-').map(Number);
                return [start, end];
            } else if (/^\d+-$/.test(range)) {
                const start = Number(range.substring(0, range.length - 1));
                return [start, Infinity];
            } else if (/^-\d+$/.test(range)) {
                const end = Number(range.substring(1));
                return [Infinity, end];
            }

            throw new HTTPError('Invalid range header.', EStatusCode.BAD_REQUEST);
        }

        function fixRange(ranges: [number, number], filesize: number): [number, number] {
            const [start, end] = ranges;

            if (start === Infinity) {
                return [Math.max(0, filesize - end - 1), filesize - 1];
            }

            if (end === Infinity || end >= filesize) {
                return [start, filesize - 1];
            }

            return [start, end];
        }

        const filesize = statSync(filename).size;
        if (req && req.headers['range']) {
            if (!req.headers['range'].startsWith('bytes=')) {
                throw new HTTPError('Invalid range header.', EStatusCode.BAD_REQUEST);
            }

            const ranges = req.headers['range'].substring('bytes='.length).split(',').map(range => fixRange(parseRange(range.trim()), filesize));
            const streams: { start: number; end: number; stream: ReadStream; }[] = [];

            for (const [start, end] of ranges) {
                if (start >= filesize || end >= filesize) {
                    throw new HTTPError('Cannot read beyond the end of the file.', EStatusCode.RANGE_NOT_SATISFIABLE, {}, {
                        'Content-Range': `bytes */${filesize}`
                    });
                }

                if (start > end || start < 0 || end < 0) {
                    throw new HTTPError('Invalid range provided.', EStatusCode.RANGE_NOT_SATISFIABLE, {}, {
                        'Content-Range': `bytes */${filesize}`
                    });
                }

                const stream = createReadStream(filename, { start, end });

                streams.push({ start, end, stream });
            }

            if (streams.length > 1) {
                return this.withHeader('Content-Type', 'multipart/byteranges')
                    .withStatus(EStatusCode.PARTIAL_CONTENT)
                    .withHeader('Accept-Ranges', 'bytes')
                    .stream(Readable.from(streams.flatMap(({ start, end, stream }) => {
                        return [
                            `--${streams.length > 1 ? 'boundary' : ''}`,
                            `Content-Type: ${lookup(filename) || 'application/octet-stream'}`,
                            `Content-Range: bytes ${start}-${end}/${filesize}`,
                            '',
                            stream
                        ];
                    })));
            } else if (streams.length === 1) { // Check for 1 to ensure that the array is not empty.
                const [{ start, end, stream }] = streams;

                return this.withHeader('Content-Type', lookup(filename) || 'application/octet-stream')
                    .withStatus(EStatusCode.PARTIAL_CONTENT)
                    .withHeader('Content-Range', `bytes ${start}-${end}/${filesize}`)
                    .withHeader('Accept-Ranges', 'bytes')
                    .stream(stream);
            }
        }

        const res = this.withHeader('Content-Type', lookup(filename) || 'text/plain')
            .stream(createReadStream(filename));

        if (req) {
            res.withHeader('Accept-Ranges', 'bytes');
        }

        return res;
    }

    /**
     * Set the status code of the response.
     *
     * @param code The status code.
     * @returns The response object.
     */
    withStatus(code: number): Response<T> {
        this.#status = code;

        return this;
    }

    /**
     * Empty the response body.
     *
     * @returns The response object.
     */
    empty(): Response<T> {
        this.#body = [];

        return this;
    }

    /**
     * Pipe the response to a Transform stream.
     *
     * @param stream The stream to be piped.
     * @returns The response object.
     */
    pipe(stream: Transform): Response<T> {
        this.#pipeStreams.push(stream);

        return this;
    }

    get headers() {
        return this.#headers;
    }

    get status() {
        return this.#status;
    }

    /**
     * Get the body of the response as a Readable stream.
     */
    get body(): Readable {
        const sourceStream = this.#stream ?? Readable.from(this.#body);

        let stream = sourceStream;

        for (const transform of this.#pipeStreams) {
            stream = stream.pipe(transform);
        }

        return stream;
    }

    /**
     * Get the length of the response body. If the response is a stream, -1 will be returned.
     */
    get length() {
        if (this.isStream) {
            return -1;
        }

        return this.#body.reduce((acc, chunk) => acc + chunk.length, 0);
    }

    /**
     * Check if the response is a stream.
     */
    get isStream() {
        return this.#stream !== undefined || this.#pipeStreams.length > 0;
    }

    /**
     * Get the early hints of the response.
     */
    get earlyHints(): Record<string, string | string[]> | null {
        if (this.#earlyHints.size == 0) {
            return null;
        }

        const hints: Record<string, string | string[]> = {};

        for (const [key, value] of this.#earlyHints) {
            hints[key] = value;
        }

        return hints;
    }

    /**
     * Send pure data. Automatically converts strings to Buffers using UTF-8 encoding.
     *
     * @param data The data to be sent. If an array is passed, each item will be sent as a separate chunk.
     * @returns The response object.
     */
    static send(data: Bufferable): Response {
        return new Response()
            .send(data);
    }

    /**
     * Send a stream. Streams have priority over other data.
     *
     * @param stream The stream to be sent.
     * @returns The response object.
     */
    static stream(stream: Streamable): Response {
        return new Response()
            .stream(stream);
    }

    /**
     * Send JSON data. The Content-Type header will be set to application/json and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    static json<T = any>(data: T, stream: boolean = false, spaces?: number): Response<T> {
        return new Response<T>()
            .json(data, stream, spaces);
    }

    /**
     * Send JSON data with BigInt support. The Content-Type header will be set to application/json-bigint and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    static jsonBigint<T = any>(data: T, stream: boolean = false, spaces?: number): Response<T> {
        return new Response<T>()
            .jsonBigint(data, stream, spaces);
    }

    /**
     * Send a Problem Details response.
     * @param title A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation).
     * @param detail A human-readable explanation specific to this occurrence of the problem.
     * @param status The HTTP status code generated by the origin server for this occurrence of the problem.
     * @param type A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
     * @param instance A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @param extensions Problem type definitions MAY extend the problem details object with additional members.
     * @returns The response object.
     */
    static problem(title: string, detail: string, status?: number, type?: string | null, instance?: string, extensions?: Record<string, unknown>): Response<ProblemDetails> {
        return new Response<ProblemDetails>()
            .problem(title, detail, status, type, instance, extensions);
    }

    /**
     * Send data based on the Accept header of the request. The Content-Type header will be set accordingly.
     *
     * @param data The data to be sent.
     * @param req The request object.
     * @param order The order of priority for the Accept header. If not set, the order will be based on the request's Accept header.
     * @returns The response object.
     */
    static auto<T = any>(data: T, req: Request, order?: string[]): Response<T> {
        return new Response<T>()
            .auto(data, req, order);
    }

    /**
     * Send a HTML response. The Content-Type header will be set to text/html.
     *
     * @param data The HTML data to be sent.
     * @returns The response object.
     */
    static html(data: string): Response {
        return new Response()
            .html(data);
    }

    /**
     * Send a File. The Content-Type header will be set based on the filename. The file will be streamed.
     *
     * @param filename The path to the file to be sent.
     * @param req The request object. If the request has a Range header, the file will be sent partially.
     * @returns The response object.
     */
    static file(filename: string, req?: Request): Response {
        return new Response()
            .file(filename, req);
    }

    /**
     * Set the status code of the response.
     *
     * @param code The status code.
     * @returns The response object.
     */
    static status(code: number): Response {
        return new Response()
            .withStatus(code);
    }

    /**
     * Send a empty (204) response.
     */
    static empty(): Response {
        return new Response()
            .withStatus(EStatusCode.NO_CONTENT);
    }

    /**
     * Send a redirect (302) response.
     */
    static redirect(to: string): Response {
        return new Response()
            .withStatus(EStatusCode.FOUND)
            .withHeader('Location', to);
    }

    /**
     * Send a permanent redirect (301) response.
     */
    static redirectPermanent(to: string): Response {
        return new Response()
            .withStatus(EStatusCode.MOVED_PERMANENTLY)
            .withHeader('Location', to);
    }

    /**
     * Send an early hint (103) response.
     */
    static earlyHint(key: string, value: string): Response {
        return new Response()
            .withEarlyHint(key, value);
    }

    static installTransformer(type: string, transformer: (data: unknown, options?: unknown) => Bufferable) {
        Response.#transformers.set(type, transformer);
    }

    static installStreamTransformer(type: string, transformer: (data: unknown, options?: unknown) => Streamable) {
        Response.#streamTransformers.set(type, transformer);
    }
}
